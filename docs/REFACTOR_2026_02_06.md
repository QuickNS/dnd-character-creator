# Architectural Refactors - February 6, 2026

## Overview

This document captures the significant architectural improvements and bug fixes completed during the February 6, 2026 development session. The primary focus was on establishing clear architectural boundaries and ensuring data-driven design throughout the codebase.

## Core Architectural Decisions

### 1. CharacterBuilder as Single Source of Truth

**Decision**: CharacterBuilder is the ONLY place where character calculations happen.

**Implementation**:
- All calculation methods in `modules/character_builder.py`:
  - `calculate_processed_ability_scores()` - Ability scores with modifiers
  - `calculate_skill_modifiers()` - All 18 skill modifiers with proficiency
  - `calculate_saving_throws()` - All 6 saving throws with proficiency  
  - `calculate_ac_options()` - All possible AC combinations from equipment
  - `calculate_weapon_attacks()` - Attack stats for all equipped weapons
  - `calculate_hp()` - Hit points with all bonuses
  - `calculate_proficiency_bonus()` - Proficiency bonus by level

- Routes and API methods are pure consumers:
  ```python
  # CORRECT PATTERN
  @app.route('/character-summary')
  def character_summary():
      builder = get_builder_from_session()
      character_data = builder.to_character()  # Get ALL calculations
      return render_template('character_summary.html', character=character_data)
  ```

**Benefits**:
- Single point of maintenance for game rules
- Consistent calculations across web display, JSON export, and PDF generation
- No calculation drift between different output formats
- Easier testing and validation

### 2. Routes as Pure Consumers

**Decision**: Flask routes and API endpoints only consume data from `builder.to_character()` and pass it to templates or export formats.

**Implementation**:
- Routes call `builder.to_character()` to get complete character data
- Templates receive pre-calculated values and only display them
- No calculations in Jinja2 templates
- No calculations in route handlers

**Files Modified**:
- `routes/character_summary.py` - Uses `builder.to_character()` for all data
- `templates/character_summary.html` - Displays pre-calculated values

### 3. Data-Driven Design (No Hardcoded Lists)

**Decision**: NEVER hardcode lists of game content. Always check against data files.

**Implementation Example - Equipment Categorization**:

❌ **BEFORE** (Hardcoded - BAD):
```python
# Had hardcoded list of weapon keywords
if any(weapon_type in item_name_lower for weapon_type in 
       ['sword', 'bow', 'axe', 'hammer', 'spear', 'javelin', ...]):
    # Categorize as weapon
```

✅ **AFTER** (Data-Driven - GOOD):
```python
# Check if item exists in weapons.json
weapon_props = self._get_weapon_properties(item)
if weapon_props:  # Item exists in data file
    # Categorize as weapon
```

**Benefits**:
- Adding new weapons only requires updating `data/equipment/weapons.json`
- No code changes needed for content additions
- Impossible to miss items due to incomplete keyword lists
- Single source of truth for game content

**Files Modified**:
- `modules/character_builder.py` - `_add_equipment_from_option()` method

## Bug Fixes

### 1. Quarterstaff Not Showing Attack Information

**Issue**: Quarterstaff from Sage background was categorized as a general item instead of a weapon, so attack calculations weren't generated.

**Root Cause**: Hardcoded weapon keyword list didn't include "quarterstaff".

**Fix**: Implemented data-driven weapon detection (see decision #3 above).

**Impact**: ALL weapons in `data/equipment/weapons.json` now automatically get proper categorization and attack calculations.

### 2. Spell Source Attribution Issues

**Previously Fixed** (earlier in session):
- Species cantrips showing wrong source (fixed spell metadata system)
- "Always Prepared" badge logic for cantrips vs leveled spells
- Class spell sources showing "Player's Handbook 2024" instead of class name
- Subclass switching not clearing previous subclass benefits

## Files Modified Summary

### Core Module
- `modules/character_builder.py`:
  - Enhanced `_add_equipment_from_option()` for data-driven weapon detection
  - Subclass switching logic with proper cleanup
  - Spell metadata tracking for source attribution

### Routes
- `routes/character_summary.py`:
  - Confirmed pure consumer pattern (already implemented)
  - Uses `builder.to_character()` for all data

### Templates  
- `templates/character_summary.html`:
  - Displays pre-calculated values
  - No calculation logic in templates

### Documentation
- `.github/copilot-instructions.md`:
  - Added "Core Architectural Principle: Single Source of Truth" section
  - Added "Data-Driven Design Principles" section
  - Updated web application architecture guidance

- `docs/ARCHITECTURE.md`:
  - Added "Core Architectural Principle" section with calculation flow diagram
  - Updated CharacterBuilder documentation with calculation methods
  - Updated Flask routes section to emphasize consumer pattern

- `docs/CURRENT_STATE.md`:
  - Updated overview with architectural principle
  - Enhanced core architecture section
  - Updated character summary display section

- `docs/REFACTOR_2026_02_06.md` (this file):
  - Complete documentation of today's refactors

## Testing

All changes validated with existing test suite:
- **176 tests passed** - No regressions introduced
- Equipment categorization fix specifically tested
- Spell metadata and source attribution verified

## Future Implications

These architectural decisions establish patterns for future development:

1. **New Calculations**: Always implement in CharacterBuilder, never in routes or templates

2. **New Content**: Add to data files, system automatically handles it

3. **New Output Formats**: Call `builder.to_character()` and use the complete data

4. **Extensions**: Follow data-driven pattern - check data files, don't hardcode lists

## Migration Notes for Contributors

If you're working on existing code or adding new features:

✅ **DO**:
- Implement calculations in CharacterBuilder methods
- Check against data files (weapons.json, spells, etc.)
- Call `builder.to_character()` in routes
- Pass pre-calculated data to templates

❌ **DON'T**:
- Calculate anything in routes or templates
- Hardcode lists of game content (weapons, spells, classes, etc.)
- Duplicate calculation logic
- Parse strings for game mechanics (use effects system)

## Questions?

See the updated documentation:
- `.github/copilot-instructions.md` - Development guidelines
- `docs/ARCHITECTURE.md` - System architecture overview
- `docs/CURRENT_STATE.md` - Current implementation status
